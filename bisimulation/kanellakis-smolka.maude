mod KS is
  sorts State Label Transition TransitionSet StateSet Partition PartitionSet .

  ops s1 s2 s3 s4 : -> State [ctor] .
  ops a b : -> Label [ctor] .

  op _-[_]->_ : State Label State -> Transition [ctor] .

  subsort State < StateSet .
  subsort Partition < PartitionSet .
  subsort Transition < TransitionSet .

  var X Y : State .
  var L : Label .
  var TS : TransitionSet .
  vars XS YS S1 S2 B : StateSet .
  vars XT YT : Transition .
  var YTS : TransitionSet .
  var P : PartitionSet .

  op empty : -> StateSet [ctor] .
  op __ : StateSet StateSet -> StateSet [assoc comm id: empty] .

  op {_} : StateSet -> Partition [ctor] .

  op pEmpty : -> PartitionSet [ctor] .
  op __ : PartitionSet PartitionSet -> PartitionSet [assoc comm id: pEmpty] .

  op transitions : -> TransitionSet [ctor] .
  eq transitions =
    (s1 -[a]-> s2) (s2 -[a]-> s3) (s3 -[b]-> s4) (s4 -[a]-> s1) .

  op none : -> TransitionSet [ctor] .
  op __ : TransitionSet TransitionSet -> TransitionSet [assoc comm id: none] .

  --- Check if state has transition via label to a state in a set
  op hasTransTo : State Label StateSet -> Bool .

  --- Matching transitions
  eq hasTransTo(X, L, empty) = false .
  eq hasTransTo(X, L, (Y YS)) =
    if transition-in((X -[L]-> Y), transitions) then true else hasTransTo(X, L, YS) fi .

  --- Check if a state is in a StateSet
  op state-in : State StateSet -> Bool .
  eq state-in(X, empty) = false .
  eq state-in(X, (X Y)) = true .
  eq state-in(X, (X YS)) = true .
  eq state-in(X, (Y YS)) = state-in(X, YS) .

  --- Check if a transition is in a TransitionSet
  op transition-in : Transition TransitionSet -> Bool .
  eq transition-in(XT, none) = false .
  eq transition-in(XT, (XT YT)) = true .
  eq transition-in(XT, (XT YTS)) = true .
  eq transition-in(XT, (YT YTS)) = transition-in(XT, YTS) .

  --- Split function: split one partition based on behavior to block B
  op splitBlock : Partition StateSet Label -> PartitionSet .
  var S : StateSet .

  eq splitBlock({S}, B, L) =
    gather(S, B, L, empty, empty) .

  --- Helper: gather states with / without transition to B via L
  op gather : StateSet StateSet Label StateSet StateSet -> PartitionSet .
  eq gather(empty, B, L, S1, S2) = 
    if S1 =/= empty and S2 =/= empty then 
      {S1} {S2} 
    else if S1 =/= empty then 
      {S1} 
    else 
      {S2} fi fi .

  eq gather((X XS), B, L, S1, S2) =
    if hasTransTo(X, L, B) 
    then gather(XS, B, L, (X S1), S2)
    else gather(XS, B, L, S1, (X S2)) fi .

  --- Placeholder: check if partition is stable
  --- (You should iterate over each block pair and check splittability)
  op isStable : PartitionSet -> Bool .
  eq isStable(P) = false .  --- For now, always refine

  --- Refinement (hardcoded for now)
  op refine : PartitionSet -> PartitionSet .
  eq refine({allStates}) = 
    splitBlock({allStates}, allStates, a) .

  --- Initial allStates
  op allStates : -> StateSet .
  eq allStates = s1 s2 s3 s4 .

  --- Entry point
  op runKS : -> PartitionSet .
  eq runKS = refine({allStates}) .

endm

